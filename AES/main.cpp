#include <iostream>
#include <fstream>
#include <string>
#include "AESManager.h"

using namespace std;

// AES 에서 사용할 S box
static unsigned char sbox[256] = {
	0x15,0x0A,0x3B,0x21,0x02,0xC7,0x0F,0xBC,0x3F,0x72,0xDD,0x8A,0x18,0x99,0xC1,0x5B,
	0xA1,0x2F,0xA6,0x4F,0xD0,0x13,0xDA,0x50,0x32,0x26,0x53,0x09,0x7F,0x60,0x93,0x3A,
	0xEE,0xCE,0xA9,0xBB,0xCC,0xC2,0x38,0xF8,0xF7,0xCD,0xBE,0xFB,0xF2,0x20,0x16,0x22,
	0x86,0x91,0x2D,0x03,0x97,0x23,0xBA,0x75,0x81,0x17,0xAF,0x44,0x56,0x04,0x82,0x19,
	0xE8,0x11,0x59,0x05,0xEA,0xD6,0xE3,0xE5,0x58,0xC4,0xFE,0xD5,0x83,0x1B,0x42,0x9F,
	0x64,0x88,0xD8,0x69,0xC0,0xD9,0xC3,0xFD,0x47,0x35,0x8F,0xFC,0x94,0x9B,0x8E,0x07,
	0x7D,0x54,0x57,0xA3,0xA8,0x4E,0xBF,0x71,0xF5,0xB1,0x0E,0xD2,0x63,0x37,0x84,0xA7,
	0x5F,0xC6,0x14,0xCA,0x48,0x10,0xBD,0x06,0xB4,0xE7,0x9D,0xA2,0xDE,0xB0,0xB2,0xAC,
	0x4A,0x43,0xB6,0xD7,0x92,0xF4,0x1D,0x76,0x4B,0x31,0x55,0x85,0xCF,0x87,0x6D,0xED,
	0x12,0x70,0x5C,0x9A,0xE0,0x9E,0xD4,0x78,0x5E,0x25,0xB3,0x7A,0x1F,0x33,0xF1,0xE9,
	0x0C,0x89,0xDB,0x1A,0xF3,0x46,0x2B,0x3E,0xFF,0x08,0x73,0x6E,0x7E,0xDC,0x61,0xE2,
	0x3C,0x7B,0xA4,0xC8,0xF9,0x8D,0xE1,0x0B,0x74,0x0D,0x52,0xB7,0x79,0x96,0x1C,0x39,
	0x80,0x68,0xB5,0x28,0x34,0x24,0xEF,0x2C,0x6A,0x45,0xB8,0x8B,0x40,0xDF,0x27,0xAB,
	0x65,0xAD,0xE6,0xEB,0x98,0x1E,0xF6,0xD1,0x2E,0x62,0xA5,0x5A,0x7C,0xAA,0x4C,0x3D,
	0x30,0xE4,0x5D,0x77,0x95,0xD3,0xFA,0x90,0x1A,0xEC,0x36,0xCB,0x41,0x8C,0x9C,0x49,
	0xC5,0xB9,0x6C,0xA0,0xF0,0x00,0x6F,0x6B,0x51,0x4D,0x66,0x13,0x67,0x29,0xC9,0xAE
};

// AES Encryption Mix Columns 연산에서 사용할 Matrix
static unsigned char MixColMat[16] = {
	0x02,0x01,0x01,0x03,
	0x03,0x02,0x01,0x01,
	0x01,0x03,0x02,0x01,
	0x01, 0x01,0x03,0x02
};

// AES Decryption Mix Columns 연산에서 사용할 Matrix
static unsigned char InvMixColMat[16] = {
	0x0E,0x09,0x0D,0x0B,
	0x0B,0x0E,0x09,0x0D,
	0x0D,0x0B,0x0E,0x09,
	0x09,0x0D,0x0B,0x0E
};

static unsigned short irreducible = 0x014D;

static void print(AESManager *manager, int sel) {
	for (int i = 0; i < 16; i++) {
		int val = sel == 0 ? (int)manager->getPlain(i) : (int)manager->getKey(i);
		cout.setf(ios::uppercase);
		cout << std::hex << val / 16 << std::hex << val % 16 << " ";
	}
	cout << "\n";
}

static void printAll(AESManager *manager) {

	cout << "RC : ";
	for (int i = 0; i < 10; i++) {
		int val = (int)manager->getRC(i);
		cout.setf(ios::uppercase);
		cout << std::hex << val / 16 << std::hex << val % 16 << " ";
	}
	cout << "\nPLAIN : ";
	print(manager, 0);
	cout << "KEY : ";
	print(manager, 1);
	cout << "\n";
	cout << "<------ ENCRYPTION ------>\n\n";
	cout << "KEY EXPANSION\n";

	for (int i = 0; i < 11; i++) {
		cout << "ROUND " << std::dec << i << ": ";
		for (int j = 0; j < 16; j++) {
			int val = (int)manager->getExpandedKey(i*16+j);
			cout.setf(ios::uppercase);
			cout << std::hex << val / 16 << std::hex << val % 16 << " ";
		}
		cout << "\n";
	}
	cout << "\n";
	cout << "Round " << std::dec << 0 << "\n";
	manager->addRoundKey(0);
	cout << "AR: ";
	print(manager, 0);
	cout << "\n";	

	// encryption
	for (int i = 1; i <= 10; i++) {
		cout << "Round " << std::dec << i << "\n";
		manager->subByte(i);
		cout << "SB: ";
		print(manager, 0);
		manager->shiftRows(i);
		cout << "SR: ";
		print(manager, 0);

		// mix col 연산은 마지막 라운드는 제외한다.
		if (i < 10) {
			manager->mixCols(i);
			cout << "MC: ";
			print(manager, 0);
		}

		manager->addRoundKey(i);
		cout << "AR: ";
		print(manager, 0);
		cout << "\n";
	}
	cout << "CIPHER : ";
	print(manager, 0);

	cout << "\n\n<------ DECRYPTION ------>\n\n";	
	// decryption
	cout << "Round " << std::dec << 0 << "\n";
	manager->addRoundKey(10);
	cout << "AR: ";
	print(manager, 0);
	cout << "\n";
	for (int i = 1; i <= 10; i++) {
		cout << "Round " << std::dec << i << "\n";		
		manager->inv_shiftRows(i);
		cout << "SR: ";
		print(manager, 0);
		manager->inv_subByte(i);
		cout << "SB: ";
		print(manager, 0);

		manager->addRoundKey(10-i);
		cout << "AR: ";
		print(manager, 0);
		// inverse mix col 연산도 마지막 라운드는 제외한다.
		if (i < 10) {
			manager->inv_mixCols(i);
			cout << "MC: ";
			print(manager, 0);
		}
		cout << "\n";
	}
	// Decryption 결과 출력
	cout << "DECRYPTED: ";
	print(manager, 0);
}

int main() {	
	unsigned char in;
	ifstream keyFile("key.bin",std::ifstream::in);
	ifstream plainFile("plain.bin", std::ifstream::in);
	AESManager *manager = new AESManager(irreducible);
	int i = 0;
		
	// file read
	if (keyFile.is_open()) {		
		i = 0;
		while (keyFile.good()) {
			in = keyFile.get();
			manager->InitializeKeyIndex(i, in);
			i++;
		}
		keyFile.close();
	}
	if (plainFile.is_open()) {
		i = 0;
		while (plainFile.good()) {
			in = plainFile.get();
			manager->InitializePlainIndex(i, in);
			i++;
		}
		plainFile.close();
	}

	// setting s_box, inverse s_box
	for (i = 0; i < 256; i++)
		manager->setSBox(i, sbox[i]);	
	manager->setInverseSBox();

	// Matrix set up
	manager->setMixColMat(MixColMat, 16);
	manager->setInverseMixColMat(InvMixColMat, 16);

	// key expansion
	manager->setKeyExpansion();

	printAll(manager);	
	return 0;
}